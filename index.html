<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Abstract Sphere Field</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            /* Dark background like the reference */
        }

        canvas {
            display: block;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: sans-serif;
            font-size: 24px;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        #controls-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.6);
            font-family: sans-serif;
            font-size: 12px;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="loading">Generating Spheres...</div>
    <!-- Added a recording indicator -->
    <div id="recording-status"
        style="position: absolute; top: 20px; right: 20px; color: red; font-family: sans-serif; font-weight: bold; display: none; align-items: center; gap: 10px;">
        <div style="width: 12px; height: 12px; background-color: red; border-radius: 50%;"></div>
        RECORDING...
    </div>
    <div id="controls-info">Mouse: Orbit | Scroll: Zoom | Right-Click: Pan</div>

    <!-- Three.js and dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Simplex Noise for organic terrain generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <!-- lil-gui for controls -->
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/dist/lil-gui.umd.min.js"></script>

    <!-- Post-Processing Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <script>
        // Configuration
        const CONFIG = {
            sphereCount: 100, // Grid size (100x100 = 10,000 spheres)
            sphereSize: 0.4,
            spacing: 0.7,
            sphereDetail: 32, // Increased from 16 to 32 for smoother spheres
            jitter: 0.15, // Random position offset
            animSpeed: 0.002,
            isPaused: false,
            autoRotate: true,
            // Shape Settings
            gridShape: 'Grid', // 'Grid', 'Sphere', 'Cube'
            particleShape: 'Sphere', // 'Sphere', 'Cube', 'Plus'
            shapeSize: 30.0, // Radius for sphere, Side for cube
            // Wave Settings
            waveAmplitude: 2.0,
            waveFrequencyX: 0.1,
            waveFrequencyZ: 0.1,
            waveSpeed: 0.01,
            // Noise Settings
            noiseStrength: 2.0,
            noiseScale: 0.05,
            noiseSpeed: 0.005,
            // Audio Settings
            audioEnabled: false,
            audioSensitivity: 1.0,
            audioSource: 'Mic', // 'Mic', 'File'
            // Environment
            fogDensity: 0.02,
            showFloor: false,
            colors: {
                base: 0xcbbae8,    // Low points
                highlight: 0x8332a9, // High points
                bg: new THREE.Color(0x050505)
            },
            // Export settings
            exportDuration: 10, // seconds
            exportFormat: 'webm', // 'webm' or 'mp4'
            // Post-Processing
            bloomStrength: 0,
            bloomRadius: 0.4,
            bloomThreshold: 0.1,
            enableBloom: true,
            // Cluster Randomization
            clusterScale: 0.02, // Controls size of clusters (lower = larger clusters)
            clusterStrength: 0.5, // 15% variation
            // Material
            materialType: 'Metal'
        };

        const MATERIALS = {
            'Metal': { roughness: 0.2, metalness: 0.6 },
            'Plastic': { roughness: 0.5, metalness: 0.0 },
            'Clay': { roughness: 0.9, metalness: 0.0 },
            'Ceramic': { roughness: 0.1, metalness: 0.1 }
        };

        // Scene Management Variables
        const SCENE_MANAGER = {
            sceneName: "My Scene 1",
            selectedScene: "",
            savedScenes: {}, // Will be loaded from localStorage

            // Actions
            saveScene: function () {
                if (!this.sceneName) return alert("Please enter a scene name");

                const sceneData = {
                    config: JSON.parse(JSON.stringify(CONFIG)), // Deep copy config
                    camera: {
                        position: camera.position.clone(),
                        target: controls.target.clone()
                    },
                    lights: {
                        dir: {
                            position: dirLight.position.clone(),
                            intensity: dirLight.intensity
                        },
                        point: {
                            position: redLight.position.clone(),
                            intensity: redLight.intensity,
                            distance: redLight.distance
                        },
                        ambient: {
                            intensity: ambientLight.intensity,
                            color: ambientLight.color.getHex(),
                            groundColor: ambientLight.groundColor.getHex()
                        },
                        rim: {
                            position: rimLight.position.clone(),
                            intensity: rimLight.intensity,
                            color: rimLight.color.getHex()
                        }
                    }
                };

                // Fix Color objects turning into weird JSON
                // (CONFIG.colors is already hex/int friendly from previous edits, but let's be safe)

                this.savedScenes[this.sceneName] = sceneData;
                localStorage.setItem('sphere_field_scenes', JSON.stringify(this.savedScenes));

                // Update dropdown
                updateSceneDropdown();
                this.selectedScene = this.sceneName;
                alert(`Scene "${this.sceneName}" saved!`);
            },

            loadSelected: function () {
                const name = this.selectedScene;
                const data = this.savedScenes[name];
                if (!data) return alert("No scene selected");

                // 1. Restore Config
                Object.assign(CONFIG, data.config);

                // Migration: Old Crater Colors -> New Wave Colors
                if (CONFIG.colors.red !== undefined) {
                    CONFIG.colors.highlight = CONFIG.colors.red;
                    delete CONFIG.colors.red;
                }
                if (CONFIG.colors.purple !== undefined) {
                    CONFIG.colors.base = CONFIG.colors.purple;
                    delete CONFIG.colors.purple;
                }
                // Migration: Ensure Wave Defaults
                if (CONFIG.waveAmplitude === undefined) {
                    CONFIG.waveAmplitude = 2.0;
                    CONFIG.waveFrequencyX = 0.2;
                    CONFIG.waveFrequencyZ = 0.2;
                    CONFIG.waveSpeed = 1.0;
                }
                // Migration: Ensure Noise Defaults
                if (CONFIG.noiseStrength === undefined) {
                    CONFIG.noiseStrength = 0.0;
                    CONFIG.noiseScale = 0.1;
                    CONFIG.noiseSpeed = 0.5;
                }
                // Migration: Ensure Shape Defaults
                if (CONFIG.gridShape === undefined) {
                    CONFIG.gridShape = 'Grid';
                    CONFIG.shapeSize = 30.0;
                }
                if (CONFIG.particleShape === undefined) CONFIG.particleShape = 'Sphere';

                // Migration: Ensure Interaction Defaults
                if (CONFIG.interactionRadius === undefined) CONFIG.interactionRadius = 8.0;
                // Migration: Ensure Audio Defaults
                if (CONFIG.audioEnabled === undefined) CONFIG.audioEnabled = false;
                if (CONFIG.audioSensitivity === undefined) CONFIG.audioSensitivity = 1.0;
                if (CONFIG.audioSource === undefined) CONFIG.audioSource = 'Mic';

                // Migration: Ensure Control Defaults
                if (CONFIG.isPaused === undefined) CONFIG.isPaused = false;
                if (CONFIG.autoRotate === undefined) CONFIG.autoRotate = true;

                // Migration: Ensure Environment Defaults
                if (CONFIG.fogDensity === undefined) CONFIG.fogDensity = 0.02;
                if (CONFIG.showFloor === undefined) CONFIG.showFloor = false;

                // Ensure colors are valid numbers/objects

                // 2. Restore Camera
                if (data.camera) {
                    camera.position.copy(data.camera.position);
                    controls.target.copy(data.camera.target);
                    controls.update();
                }

                // 3. Restore Lights
                if (data.lights) {
                    dirLight.position.copy(data.lights.dir.position);
                    dirLight.intensity = data.lights.dir.intensity;

                    redLight.position.copy(data.lights.point.position);
                    redLight.intensity = data.lights.point.intensity;
                    redLight.distance = data.lights.point.distance;

                    if (data.lights.ambient) {
                        ambientLight.intensity = data.lights.ambient.intensity;
                        ambientLight.color.setHex(data.lights.ambient.color);
                        ambientLight.groundColor.setHex(data.lights.ambient.groundColor);
                    }

                    if (data.lights.rim) {
                        rimLight.position.copy(data.lights.rim.position);
                        rimLight.intensity = data.lights.rim.intensity;
                        rimLight.color.setHex(data.lights.rim.color);
                    }
                }

                // 4. Update GUI to reflect new values
                // We recursively update all controllers in the GUI
                gui.controllersRecursive().forEach(c => c.updateDisplay());

                // 5. Re-init logic
                document.getElementById('loading').style.opacity = 1;
                setTimeout(() => {
                    initSpheres();
                    // Force background update
                    scene.background = new THREE.Color(CONFIG.colors.bg);
                    scene.fog.color = new THREE.Color(CONFIG.colors.bg);
                    scene.fog.density = CONFIG.fogDensity;

                    floor.visible = CONFIG.showFloor;
                }, 50);
            },

            deleteScene: function () {
                if (!this.selectedScene) return;
                if (confirm(`Delete scene "${this.selectedScene}"?`)) {
                    delete this.savedScenes[this.selectedScene];
                    localStorage.setItem('sphere_field_scenes', JSON.stringify(this.savedScenes));
                    updateSceneDropdown();
                    this.selectedScene = "";
                }
            }
        };

        // Setup Scene
        const scene = new THREE.Scene();
        scene.background = CONFIG.colors.bg;
        scene.fog = new THREE.FogExp2(CONFIG.colors.bg, CONFIG.fogDensity);

        // Floor Plane
        const floorGeo = new THREE.PlaneGeometry(400, 400);
        const floorMat = new THREE.MeshStandardMaterial({
            color: 0x111111,
            roughness: 0.1,
            metalness: 0.5
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -10; // Below the lowest wave point
        floor.receiveShadow = true;
        floor.visible = CONFIG.showFloor;
        scene.add(floor);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(20, 15, 20);

        const renderer = new THREE.WebGLRenderer({
            antialias: true,
            powerPreference: 'high-performance'
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        // Added Pixel Ratio for sharp rendering on high-DPI screens (Retina displays)
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // Post-Processing Setup
        const renderScene = new THREE.RenderPass(scene, camera);

        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = CONFIG.bloomThreshold;
        bloomPass.strength = CONFIG.bloomStrength;
        bloomPass.radius = CONFIG.bloomRadius;

        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // Lighting
        const ambientLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 50, 20);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 150;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 150;
        dirLight.shadow.camera.left = -100;
        dirLight.shadow.camera.right = 100;
        dirLight.shadow.camera.top = 100;
        dirLight.shadow.camera.bottom = -100;
        dirLight.shadow.bias = -0.0005;
        scene.add(dirLight);

        // Add a specific light for the red crater to make it pop
        // Add a specific light for the red crater to make it pop
        const redLight = new THREE.PointLight(0xff5555, 2.0, 30); // Increased intensity and range for bloom
        redLight.position.set(0, 2, 0);
        scene.add(redLight);

        // Rim Light (Backlight) for cinematic separation
        const rimLight = new THREE.SpotLight(0x4455ff, 2.0);
        rimLight.position.set(-20, 10, -20);
        rimLight.lookAt(0, 0, 0);
        scene.add(rimLight);

        // Variables that need to be accessed globally for regeneration
        let mesh;
        // let positions = []; // No longer needed for CPU animation
        let customUniforms = {
            uTime: { value: 0 },
            uWaveAmp: { value: 2.0 },
            uWaveFreqX: { value: 0.1 },
            uWaveFreqZ: { value: 0.1 },
            uWaveSpeed: { value: 0.01 },
            uNoiseStrength: { value: 2.0 },
            uNoiseScale: { value: 0.05 },
            uNoiseSpeed: { value: 0.005 },
            uBaseColor: { value: new THREE.Color(0x5500ff) },
            uHighlightColor: { value: new THREE.Color(0xff0055) },
            uAudioBass: { value: 0.0 },
            uAudioMids: { value: 0.0 },
            uAudioHighs: { value: 0.0 },
            uClusterScale: { value: 0.02 },
            uClusterStrength: { value: 0.5 }
        };

        // GLSL Noise Function (Simplex 3D)
        const noiseGLSL = `
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            float snoise(vec3 v) {
                const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
                const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i  = floor(v + dot(v, C.yyy) );
                vec3 x0 = v - i + dot(i, C.xxx) ;
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
                vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y
                i = mod289(i);
                vec4 p = permute( permute( permute(
                            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                        + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                        + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                float n_ = 0.142857142857; // 1.0/7.0
                vec3  ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)
                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                p0 *= norm.x;
                p1 *= norm.y;
                p2 *= norm.z;
                p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
            }
            // Simplex 2D for cluster
            vec3 mod289_2(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec2 mod289_2(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec3 permute_2(vec3 x) { return mod289_2(((x*34.0)+1.0)*x); }
            float snoise(vec2 v) {
                const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0
                                    0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)
                                    -0.577350269189626,  // -1.0 + 2.0 * C.x
                                    0.024390243902439); // 1.0 / 41.0
                vec2 i  = floor(v + dot(v, C.yy) );
                vec2 x0 = v - i + dot(i, C.xx);
                vec2 i1;
                i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
                vec4 x12 = x0.xyxy + C.xxzz;
                x12.xy -= i1;
                i = mod289_2(i); // Avoid truncation effects in permutation
                vec3 p = permute_2( permute_2( i.y + vec3(0.0, i1.y, 1.0 ))
                    + i.x + vec3(0.0, i1.x, 1.0 ));
                vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
                m = m*m ;
                m = m*m ;
                vec3 x = 2.0 * fract(p * C.www) - 1.0;
                vec3 h = abs(x) - 0.5;
                vec3 ox = floor(x + 0.5);
                vec3 a0 = x - ox;
                m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
                vec3 g;
                g.x  = a0.x  * x0.x  + h.x  * x0.y;
                g.yz = a0.yz * x12.xz + h.yz * x12.yw;
                return 130.0 * dot(m, g);
            }
        `;
        const simplex = new SimplexNoise();
        const dummy = new THREE.Object3D();
        const _color = new THREE.Color();
        // Helper color objects for the GUI
        const _baseColor = new THREE.Color();
        const _highlightColor = new THREE.Color();

        // Helper class for GUI colors
        class ColorGUIHelper {
            constructor(object, prop) {
                this.object = object;
                this.prop = prop;
            }
            get value() {
                return `#${this.object[this.prop].getHexString()}`;
            }
            set value(hexString) {
                this.object[this.prop].set(hexString);
            }
        }

        // Recording Logic
        function exportVideo() {
            const statusEl = document.getElementById('recording-status');
            const canvas = renderer.domElement;

            // Check support
            if (!window.MediaRecorder) {
                alert("Your browser does not support MediaRecorder API");
                return;
            }

            statusEl.style.display = 'flex';

            // Capture the stream at 30fps
            const stream = canvas.captureStream(30);

            // Determine Mime Type based on selection and support
            let mimeType = '';
            if (CONFIG.exportFormat === 'mp4') {
                if (MediaRecorder.isTypeSupported('video/mp4;codecs=h264')) {
                    mimeType = 'video/mp4;codecs=h264';
                } else if (MediaRecorder.isTypeSupported('video/mp4')) {
                    mimeType = 'video/mp4';
                } else {
                    alert("MP4 export is not supported by your browser. Falling back to WebM.");
                    CONFIG.exportFormat = 'webm'; // Fallback
                }
            }

            // If still empty (webm selected or fallback)
            if (!mimeType) {
                const webmTypes = [
                    'video/webm;codecs=vp9',
                    'video/webm;codecs=vp8',
                    'video/webm'
                ];
                mimeType = webmTypes.find(type => MediaRecorder.isTypeSupported(type)) || '';
            }

            if (!mimeType) {
                alert("No supported video mime type found.");
                statusEl.style.display = 'none';
                return;
            }

            const extension = CONFIG.exportFormat === 'mp4' ? 'mp4' : 'webm';
            console.log(`Exporting ${CONFIG.exportFormat.toUpperCase()} with mimeType: ${mimeType}`);

            let recorder;
            try {
                recorder = new MediaRecorder(stream, {
                    mimeType: mimeType,
                    videoBitsPerSecond: 8000000 // 8 Mbps
                });
            } catch (e) {
                console.error("MediaRecorder creation failed", e);
                alert("Failed to create MediaRecorder: " + e.message);
                statusEl.style.display = 'none';
                return;
            }

            const chunks = [];

            recorder.ondataavailable = (e) => {
                if (e.data.size > 0) chunks.push(e.data);
            };

            recorder.onstop = () => {
                statusEl.style.display = 'none';

                if (chunks.length === 0) {
                    alert("Recording failed: No data captured.");
                    return;
                }

                const blob = new Blob(chunks, { type: mimeType });
                console.log(`Exporting video: ${blob.size} bytes, type: ${mimeType}`);

                // Use URL.createObjectURL for better performance and reliability
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;

                // Sanitize filename
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                a.download = `sphere-field-demo-${timestamp}.${extension}`;

                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                // Cleanup
                setTimeout(() => URL.revokeObjectURL(url), 1000);
            };

            recorder.start();

            // Stop after exportDuration
            setTimeout(() => {
                if (recorder.state === 'recording') {
                    recorder.stop();
                }
            }, CONFIG.exportDuration * 1000);
        }

        function initSpheres() {
            // Cleanup existing mesh if it exists
            if (mesh) {
                scene.remove(mesh);
                mesh.geometry.dispose();
                mesh.material.dispose();
                mesh = null;
            }

            // Use sphereDetail config here
            let geometry;
            const s = CONFIG.sphereSize;

            if (CONFIG.particleShape === 'Cube') {
                geometry = new THREE.BoxGeometry(s, s, s);
            } else if (CONFIG.particleShape === 'Plus') {
                const shape = new THREE.Shape();
                const t = s * 0.3; // thickness
                const h = s; // half size roughly

                shape.moveTo(t, h);
                shape.lineTo(h, h);
                shape.lineTo(h, -h);
                shape.lineTo(t, -h);
                shape.lineTo(t, -s * 2); // Long tail? No, let's make it symmetric
                // Actually, let's draw a proper cross
                // Center 0,0. Size s.
                // Top arm
                shape.moveTo(-t, s);
                shape.lineTo(t, s);
                shape.lineTo(t, t);
                // Right arm
                shape.lineTo(s, t);
                shape.lineTo(s, -t);
                shape.lineTo(t, -t);
                // Bottom arm
                shape.lineTo(t, -s);
                shape.lineTo(-t, -s);
                shape.lineTo(-t, -t);
                // Left arm
                shape.lineTo(-s, -t);
                shape.lineTo(-s, t);
                shape.lineTo(-t, t);

                geometry = new THREE.ShapeGeometry(shape);
            } else {
                // Default Sphere
                geometry = new THREE.SphereGeometry(s, CONFIG.sphereDetail, CONFIG.sphereDetail);
            }

            const matProps = MATERIALS[CONFIG.materialType] || MATERIALS['Metal'];
            const material = new THREE.MeshStandardMaterial({
                roughness: matProps.roughness,
                metalness: matProps.metalness,
                side: THREE.DoubleSide
            });

            // INJECT SHADER CODE
            material.onBeforeCompile = (shader) => {
                // Pass uniforms
                Object.assign(shader.uniforms, customUniforms);

                shader.vertexShader = `
                    uniform float uTime;
                    uniform float uWaveAmp;
                    uniform float uWaveFreqX;
                    uniform float uWaveFreqZ;
                    uniform float uWaveSpeed;
                    uniform float uNoiseStrength;
                    uniform float uNoiseScale;
                    uniform float uNoiseSpeed;
                    uniform vec3 uBaseColor;
                    uniform vec3 uHighlightColor;
                    uniform float uAudioBass;
                    uniform float uAudioMids;
                    uniform float uAudioHighs;
                    uniform float uClusterScale;
                    uniform float uClusterStrength;

                    attribute vec3 aCustomNormal;
                    attribute float aColorOffset;
                    
                    varying vec3 vColor;

                    ${noiseGLSL}
                ` + shader.vertexShader;

                // Replace <begin_vertex>
                shader.vertexShader = shader.vertexShader.replace(
                    '#include <begin_vertex>',
                    `
                    vec3 transformed = vec3( position );
                    
                    // Get base position from instanceMatrix (column 3)
                    vec3 basePos = vec3( instanceMatrix[3][0], instanceMatrix[3][1], instanceMatrix[3][2] );
                    
                    // --- AUDIO MODULATION ---
                    float modAmp = uWaveAmp + (uAudioBass * 5.0 * 1.0); // Sensitivity hardcoded or passed? Passed via config update
                    float modNoise = uNoiseStrength + (uAudioMids * 5.0 * 1.0);

                    // --- WAVE ---
                    float t = uTime * uWaveSpeed;
                    float waveX = sin(basePos.x * uWaveFreqX + t);
                    float waveZ = cos(basePos.z * uWaveFreqZ + t);
                    float waveY = sin(basePos.y * uWaveFreqX + t);
                    
                    float displacement = (waveX + waveZ + waveY) * modAmp;

                    // --- NOISE ---
                    if (modNoise > 0.0) {
                        float n = snoise(basePos * uNoiseScale + vec3(0.0, 0.0, t * uNoiseSpeed * 100.0)); // 3D noise
                        displacement += n * modNoise;
                    }

                    // --- APPLY DISPLACEMENT ---
                    // Apply along custom normal
                    vec3 finalPos = basePos + (aCustomNormal * displacement);
                    
                    // We need to transform 'transformed' (local vertex) to this new position.
                    // Since we are using InstancedMesh, 'transformed' is local.
                    // The instanceMatrix handles the base position.
                    // So we effectively want to ADD the displacement * normal to the local vertex position?
                    // No, we want to move the whole instance.
                    // But InstancedMesh vertex shader usually does: position = instanceMatrix * vec4(position, 1.0)
                    // We can modify the instanceMatrix result or just add to 'transformed' if we treat it as world offset?
                    // Actually, simpler:
                    // The 'instanceMatrix' puts the mesh at 'basePos'.
                    // We want to move it by (aCustomNormal * displacement).
                    // So we can just add that to 'transformed'.
                    // BUT 'transformed' is in local space. 'aCustomNormal' is likely in World space (or same space as basePos).
                    // If the instance is not rotated, local space == world space (relative to instance center).
                    // Our instances are NOT rotated (identity matrix for rotation), only translated.
                    // So we can just add the displacement vector to 'transformed'.
                    
                    transformed += (aCustomNormal * displacement);

                    // --- SCALE ---
                    float totalAmp = (modAmp * 3.0) + modNoise + 0.001;
                    float normDisp = (displacement / totalAmp) + 0.5;
                    float scale = 1.0 + (normDisp * 0.5);
                    
                    // Cluster Scale
                    float clusterNoise = snoise(basePos.xz * uClusterScale + 100.0);
                    scale *= (1.0 + (clusterNoise * uClusterStrength));

                    // Audio Highs Jitter
                    // scale += (uAudioHighs * fract(sin(dot(basePos.xy ,vec2(12.9898,78.233))) * 43758.5453)); // Pseudo random
                    
                    transformed *= scale;

                    // --- COLOR ---
                    float mixVal = clamp(normDisp, 0.0, 1.0);
                    mixVal += uAudioHighs;
                    mixVal = clamp(mixVal, 0.0, 1.0);
                    
                    vec3 c = mix(uBaseColor, uHighlightColor, mixVal);
                    // Random variation
                    // c += (aColorOffset - 0.5) * 0.1; // Simple RGB offset or HSL?
                    // HSL in shader is expensive, let's just do simple RGB tint
                    c += vec3((aColorOffset - 0.5) * 0.1);
                    
                    vColor = c;
                    `
                );

                // Inject Color Varying to Fragment
                shader.fragmentShader = `
                    varying vec3 vColor;
                ` + shader.fragmentShader;

                shader.fragmentShader = shader.fragmentShader.replace(
                    '#include <color_fragment>',
                    `
                    #include <color_fragment>
                    diffuseColor.rgb = vColor;
                    `
                );

                // Store shader for updates if needed (though we use customUniforms object)
                material.userData.shader = shader;
            };

            const count = CONFIG.sphereCount * CONFIG.sphereCount;
            mesh = new THREE.InstancedMesh(geometry, material, count);
            mesh.castShadow = true;
            mesh.receiveShadow = true;

            // Attributes
            const customNormals = new Float32Array(count * 3);
            const colorOffsets = new Float32Array(count);

            let index = 0;
            const dummy = new THREE.Object3D();

            // Helper to set data
            const setInstance = (i, x, y, z, nx, ny, nz) => {
                dummy.position.set(x, y, z);
                dummy.updateMatrix();
                mesh.setMatrixAt(i, dummy.matrix);

                customNormals[i * 3] = nx;
                customNormals[i * 3 + 1] = ny;
                customNormals[i * 3 + 2] = nz;

                colorOffsets[i] = Math.random();
            };

            if (CONFIG.gridShape === 'Grid') {
                const offset = (CONFIG.sphereCount * CONFIG.spacing) / 2;
                for (let x = 0; x < CONFIG.sphereCount; x++) {
                    for (let z = 0; z < CONFIG.sphereCount; z++) {
                        const posX = (x * CONFIG.spacing) - offset;
                        const posZ = (z * CONFIG.spacing) - offset;
                        const jitter = CONFIG.jitter;
                        const finalX = posX + (Math.random() * jitter - jitter / 2);
                        const finalZ = posZ + (Math.random() * jitter - jitter / 2);

                        setInstance(index, finalX, 0, finalZ, 0, 1, 0);
                        index++;
                    }
                }
            } else if (CONFIG.gridShape === 'Sphere') {
                for (let i = 0; i < count; i++) {
                    const phi = Math.acos(1 - 2 * (i + 0.5) / count);
                    const theta = Math.PI * (1 + Math.sqrt(5)) * i;
                    const x = Math.cos(theta) * Math.sin(phi);
                    const y = Math.cos(phi);
                    const z = Math.sin(theta) * Math.sin(phi);
                    const r = CONFIG.shapeSize;
                    const jX = (Math.random() * CONFIG.jitter - CONFIG.jitter / 2);
                    const jY = (Math.random() * CONFIG.jitter - CONFIG.jitter / 2);
                    const jZ = (Math.random() * CONFIG.jitter - CONFIG.jitter / 2);

                    setInstance(index, (x * r) + jX, (y * r) + jY, (z * r) + jZ, x, y, z);
                    index++;
                }
            } else if (CONFIG.gridShape === 'Cube') {
                const side = CONFIG.shapeSize;
                const half = side / 2;
                const pointsPerFace = Math.floor(count / 6);
                const gridDim = Math.floor(Math.sqrt(pointsPerFace));
                const step = gridDim > 1 ? side / (gridDim - 1) : 0;
                const offset = side / 2;
                const faces = [
                    { u: 'x', v: 'y', w: 'z', wVal: half, n: { x: 0, y: 0, z: 1 } },
                    { u: 'x', v: 'y', w: 'z', wVal: -half, n: { x: 0, y: 0, z: -1 } },
                    { u: 'z', v: 'y', w: 'x', wVal: half, n: { x: 1, y: 0, z: 0 } },
                    { u: 'z', v: 'y', w: 'x', wVal: -half, n: { x: -1, y: 0, z: 0 } },
                    { u: 'x', v: 'z', w: 'y', wVal: half, n: { x: 0, y: 1, z: 0 } },
                    { u: 'x', v: 'z', w: 'y', wVal: -half, n: { x: 0, y: -1, z: 0 } }
                ];
                for (const face of faces) {
                    for (let i = 0; i < gridDim; i++) {
                        for (let j = 0; j < gridDim; j++) {
                            const uPos = gridDim > 1 ? (i * step) - offset : 0;
                            const vPos = gridDim > 1 ? (j * step) - offset : 0;
                            const jU = uPos + (Math.random() * CONFIG.jitter - CONFIG.jitter / 2);
                            const jV = vPos + (Math.random() * CONFIG.jitter - CONFIG.jitter / 2);
                            const jW = face.wVal + (Math.random() * CONFIG.jitter - CONFIG.jitter / 2);
                            const pos = { x: 0, y: 0, z: 0 };
                            pos[face.u] = jU;
                            pos[face.v] = jV;
                            pos[face.w] = jW;

                            setInstance(index, pos.x, pos.y, pos.z, face.n.x, face.n.y, face.n.z);
                            index++;
                        }
                    }
                }
            }

            mesh.geometry.setAttribute('aCustomNormal', new THREE.InstancedBufferAttribute(customNormals, 3));
            mesh.geometry.setAttribute('aColorOffset', new THREE.InstancedBufferAttribute(colorOffsets, 1));

            scene.add(mesh);
            document.getElementById('loading').style.opacity = 0;
        }

        // Initialize
        initSpheres();

        // GUI Setup
        const gui = new lil.GUI();

        // Load scenes from storage
        try {
            const stored = localStorage.getItem('sphere_field_scenes');
            if (stored) {
                SCENE_MANAGER.savedScenes = JSON.parse(stored);
            }
        } catch (e) { console.error("Error loading scenes", e); }

        // SCENE MANAGEMENT FOLDER
        const savesFolder = gui.addFolder('Scene Manager');
        savesFolder.add(SCENE_MANAGER, 'sceneName').name('Scene Name');
        savesFolder.add(SCENE_MANAGER, 'saveScene').name('Save Current Scene');

        let sceneController;
        function updateSceneDropdown() {
            // Remove old controller if exists
            if (sceneController) sceneController.destroy();

            const options = Object.keys(SCENE_MANAGER.savedScenes);
            if (options.length > 0) {
                sceneController = savesFolder.add(SCENE_MANAGER, 'selectedScene', options).name('Saved Scenes');
            } else {
                // Placeholder if empty
                SCENE_MANAGER.selectedScene = "";
                sceneController = savesFolder.add(SCENE_MANAGER, 'selectedScene', ["No scenes"]).name('Saved Scenes').disable();
            }
        }
        updateSceneDropdown();

        savesFolder.add(SCENE_MANAGER, 'loadSelected').name('Load Selected');
        savesFolder.add(SCENE_MANAGER, 'deleteScene').name('Delete Selected');

        const simFolder = gui.addFolder('Simulation');
        simFolder.add(CONFIG, 'isPaused').name('Pause Animation');
        simFolder.add(CONFIG, 'autoRotate').name('Auto Rotate');
        simFolder.add(CONFIG, 'sphereCount', 10, 200, 1)
            .name('Grid Size')
            .onFinishChange(() => {
                document.getElementById('loading').style.opacity = 1;
                setTimeout(initSpheres, 50);
            });

        simFolder.add(CONFIG, 'sphereSize', 0.1, 1.5)
            .name('Particle Size')
            .onFinishChange(() => {
                document.getElementById('loading').style.opacity = 1;
                setTimeout(initSpheres, 50);
            });

        simFolder.add(CONFIG, 'particleShape', ['Sphere', 'Cube', 'Plus'])
            .name('Particle Shape')
            .onFinishChange(() => {
                document.getElementById('loading').style.opacity = 1;
                setTimeout(initSpheres, 50);
            });

        // NEW: Spacing control to adjust the gap between spheres
        simFolder.add(CONFIG, 'spacing', 0.1, 2.0)
            .name('Spacing')
            .onFinishChange(() => {
                document.getElementById('loading').style.opacity = 1;
                setTimeout(initSpheres, 50);
            });

        // Added Sphere Detail Control
        simFolder.add(CONFIG, 'sphereDetail', 8, 64, 1)
            .name('Sphere Detail')
            .onFinishChange(() => {
                document.getElementById('loading').style.opacity = 1;
                setTimeout(initSpheres, 50);
            });

        simFolder.add(CONFIG, 'jitter', 0, 1.0)
            .name('Grid Jitter')
            .onFinishChange(() => {
                document.getElementById('loading').style.opacity = 1;
                setTimeout(initSpheres, 50);
            });

        simFolder.add(CONFIG, 'gridShape', ['Grid', 'Sphere', 'Cube'])
            .name('Shape')
            .onFinishChange(() => {
                document.getElementById('loading').style.opacity = 1;
                setTimeout(initSpheres, 50);
            });

        simFolder.add(CONFIG, 'shapeSize', 5, 100)
            .name('Shape Size')
            .onFinishChange(() => {
                document.getElementById('loading').style.opacity = 1;
                setTimeout(initSpheres, 50);
            });

        simFolder.add({
            resetToPerfect: () => {
                CONFIG.jitter = 0;
                CONFIG.waveAmplitude = 0;
                CONFIG.noiseStrength = 0;
                // Keep interaction settings as is, or reset? Let's keep them.

                // Update GUI controllers
                gui.controllersRecursive().forEach(c => c.updateDisplay());
                initSpheres();
            }
        }, 'resetToPerfect').name('Reset to Perfect');

        const fixOverlap = () => {
            // Calculate minimum safe spacing
            // Diameter = sphereSize * 2
            // Max Scale = 1.0 + (clusterStrength) + (noise * 0.2) -> roughly 1.0 + 0.15 + 0.2 = 1.35
            // Let's be safe and assume max scale is around 1.4
            const maxScale = 1.0 + CONFIG.clusterStrength + 0.2;
            const maxDiameter = (CONFIG.sphereSize * 2) * maxScale;

            // Jitter adds +/- jitter/2 to position. Max spread between two points is jitter.
            // So we need spacing > maxDiameter + jitter

            const safeSpacing = maxDiameter + CONFIG.jitter + 0.05; // 0.05 buffer

            CONFIG.spacing = safeSpacing;

            // Update GUI
            // We need to find the controller for spacing. 
            // Since we don't have a direct reference easily without iterating, 
            // we can just update the display of all controllers in this folder.
            simFolder.controllers.forEach(c => c.updateDisplay());

            initSpheres();
            alert(`Spacing adjusted to ${safeSpacing.toFixed(3)} to prevent overlap.`);
        };

        simFolder.add({ fixOverlap }, 'fixOverlap').name('Auto-Fix Overlap');

        simFolder.add(CONFIG, 'materialType', Object.keys(MATERIALS))
            .name('Material')
            .onFinishChange(() => {
                document.getElementById('loading').style.opacity = 1;
                setTimeout(initSpheres, 50);
            });

        simFolder.add(CONFIG, 'animSpeed', 0, 0.01).name('Anim Speed');

        const waveFolder = gui.addFolder('Wave Controls');
        waveFolder.add(CONFIG, 'waveAmplitude', 0, 10).name('Amplitude');
        waveFolder.add(CONFIG, 'waveFrequencyX', 0, 1.0).name('Frequency X');
        waveFolder.add(CONFIG, 'waveFrequencyZ', 0, 1.0).name('Frequency Z');
        waveFolder.add(CONFIG, 'waveSpeed', 0, 5.0).name('Speed');
        waveFolder.addColor(CONFIG.colors, 'base').name('Base Color');
        waveFolder.addColor(CONFIG.colors, 'highlight').name('Highlight Color');

        const noiseFolder = gui.addFolder('Noise Controls');
        noiseFolder.add(CONFIG, 'noiseStrength', 0, 10).name('Strength');
        noiseFolder.add(CONFIG, 'noiseScale', 0.001, 0.2).name('Scale');
        noiseFolder.add(CONFIG, 'noiseSpeed', 0, 0.05).name('Speed');

        const audioFolder = gui.addFolder('Audio Reactivity');
        audioFolder.add({ startMic: () => setupAudio('Mic') }, 'startMic').name('Start Microphone');
        audioFolder.add({ playFile: () => setupAudio('File') }, 'playFile').name('Upload Audio File');
        audioFolder.add({ stopAudio }, 'stopAudio').name('Stop Audio');
        audioFolder.add(CONFIG, 'audioSensitivity', 0, 5.0).name('Sensitivity');

        const envFolder = gui.addFolder('Environment');
        envFolder.add(CONFIG, 'fogDensity', 0, 0.1).name('Fog Density')
            .onChange(v => scene.fog.density = v);
        envFolder.add(CONFIG, 'showFloor').name('Show Floor')
            .onChange(v => floor.visible = v);

        const sunFolder = gui.addFolder('Sun Light (Directional)');
        sunFolder.add(dirLight.position, 'x', -100, 100).name('Pos X');
        sunFolder.add(dirLight.position, 'y', 0, 100).name('Pos Y');
        sunFolder.add(dirLight.position, 'z', -100, 100).name('Pos Z');
        sunFolder.add(dirLight, 'intensity', 0, 3).name('Intensity');

        const ambientFolder = gui.addFolder('Ambient Light');
        ambientFolder.add(ambientLight, 'intensity', 0, 2).name('Intensity');
        ambientFolder.addColor(new ColorGUIHelper(ambientLight, 'color'), 'value').name('Sky Color');
        ambientFolder.addColor(new ColorGUIHelper(ambientLight, 'groundColor'), 'value').name('Ground Color');

        const rimFolder = gui.addFolder('Rim Light (Spot)');
        rimFolder.add(rimLight.position, 'x', -50, 50).name('Pos X');
        rimFolder.add(rimLight.position, 'y', 0, 50).name('Pos Y');
        rimFolder.add(rimLight.position, 'z', -50, 50).name('Pos Z');
        rimFolder.add(rimLight, 'intensity', 0, 5).name('Intensity');
        rimFolder.addColor(new ColorGUIHelper(rimLight, 'color'), 'value').name('Color');

        const redFolder = gui.addFolder('Point Light');
        redFolder.add(redLight.position, 'x', -50, 50).name('Pos X');
        redFolder.add(redLight.position, 'y', 0, 50).name('Pos Y');
        redFolder.add(redLight.position, 'z', -50, 50).name('Pos Z');
        redFolder.add(redLight, 'intensity', 0, 5).name('Intensity');
        redFolder.add(redLight, 'distance', 0, 100).name('Distance (Range)');

        const exportFolder = gui.addFolder('Export');
        exportFolder.add(CONFIG, 'exportDuration', 1, 60, 1).name('Duration (sec)');
        exportFolder.add(CONFIG, 'exportFormat', ['webm', 'mp4']).name('Format');
        exportFolder.add({ exportVideo }, 'exportVideo').name('Record Video');

        const bloomFolder = gui.addFolder('Post-Processing (Bloom)');
        bloomFolder.add(CONFIG, 'enableBloom').name('Enable Bloom');
        bloomFolder.add(CONFIG, 'bloomStrength', 0, 3).onChange(v => bloomPass.strength = v);
        bloomFolder.add(CONFIG, 'bloomRadius', 0, 1).onChange(v => bloomPass.radius = v);
        bloomFolder.add(CONFIG, 'bloomThreshold', 0, 1).onChange(v => bloomPass.threshold = v);

        const clusterFolder = gui.addFolder('Cluster Randomization');
        clusterFolder.add(CONFIG, 'clusterScale', 0.01, 0.5).name('Cluster Scale (Size)');
        clusterFolder.add(CONFIG, 'clusterStrength', 0, 0.5).name('Variation Strength');





        // --- AUDIO REACTIVITY SETUP ---
        let audioContext, analyser, dataArray, source;
        let audioEl; // For file playback

        async function setupAudio(type) {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }

            // Cleanup old source
            if (source) {
                source.disconnect();
                if (audioEl) {
                    audioEl.pause();
                    audioEl = null;
                }
            }

            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256; // 128 bins
            dataArray = new Uint8Array(analyser.frequencyBinCount);

            if (type === 'Mic') {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    source = audioContext.createMediaStreamSource(stream);
                    source.connect(analyser);
                    alert("Microphone connected! Speak or clap to see effects.");
                } catch (err) {
                    console.error("Mic Error:", err);
                    alert("Could not access microphone. Check permissions.");
                }
            } else if (type === 'File') {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'audio/*';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const url = URL.createObjectURL(file);
                        audioEl = new Audio(url);
                        audioEl.play();
                        audioEl.loop = true;
                        source = audioContext.createMediaElementSource(audioEl);
                        source.connect(analyser);
                        source.connect(audioContext.destination); // Play to speakers
                    }
                };
                input.click();
            }

            CONFIG.audioEnabled = true;
        }

        function stopAudio() {
            if (source) {
                source.disconnect();
                // If it's a media stream (Mic), stop the tracks to release the mic
                if (source.mediaStream) {
                    source.mediaStream.getTracks().forEach(track => track.stop());
                }
                source = null;
            }

            if (audioEl) {
                audioEl.pause();
                audioEl.src = "";
                audioEl = null;
            }

            CONFIG.audioEnabled = false;
            // Reset modulation values in next frame automatically by logic
        }

        // Animation Loop
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);

            // Audio Analysis
            let bass = 0, mids = 0, highs = 0;
            if (CONFIG.audioEnabled && analyser) {
                analyser.getByteFrequencyData(dataArray);

                // Simple frequency bands (fftSize 256 -> 128 bins)
                // 0-10: Bass
                // 11-60: Mids
                // 61-127: Highs

                const getAvg = (start, end) => {
                    let sum = 0;
                    for (let i = start; i <= end; i++) sum += dataArray[i];
                    return sum / (end - start + 1);
                };

                bass = getAvg(0, 10) / 255; // 0.0 to 1.0
                mids = getAvg(11, 60) / 255;
                highs = getAvg(61, 127) / 255;

                // Modulate CONFIG values temporarily for this frame
                // We need to store base values if we want to return to them, 
                // but for now let's just ADD to the base config.

                // Actually, let's just pass these modifiers to updateSpheres
            }

            // Update Uniforms
            if (!CONFIG.isPaused) {
                time += CONFIG.animSpeed;
                customUniforms.uTime.value = time;
            }

            // Sync Uniforms with CONFIG
            customUniforms.uWaveAmp.value = CONFIG.waveAmplitude;
            customUniforms.uWaveFreqX.value = CONFIG.waveFrequencyX;
            customUniforms.uWaveFreqZ.value = CONFIG.waveFrequencyZ;
            customUniforms.uWaveSpeed.value = CONFIG.waveSpeed;
            customUniforms.uNoiseStrength.value = CONFIG.noiseStrength;
            customUniforms.uNoiseScale.value = CONFIG.noiseScale;
            customUniforms.uNoiseSpeed.value = CONFIG.noiseSpeed;
            customUniforms.uNoiseScale.value = CONFIG.noiseScale;
            customUniforms.uNoiseSpeed.value = CONFIG.noiseSpeed;
            customUniforms.uBaseColor.value.setHex(CONFIG.colors.base);
            customUniforms.uHighlightColor.value.setHex(CONFIG.colors.highlight);
            customUniforms.uAudioBass.value = bass * CONFIG.audioSensitivity;
            customUniforms.uAudioMids.value = mids * CONFIG.audioSensitivity;
            customUniforms.uAudioHighs.value = highs * CONFIG.audioSensitivity;
            customUniforms.uClusterScale.value = CONFIG.clusterScale;
            customUniforms.uClusterStrength.value = CONFIG.clusterStrength;

            controls.autoRotate = CONFIG.autoRotate;
            controls.update();

            // Bloom
            if (CONFIG.enableBloom) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }

        animate();

        // Resize Handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>

</html>
