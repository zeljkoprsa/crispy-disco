<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Abstract Sphere Field</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #111;
            /* Dark background like the reference */
        }

        canvas {
            display: block;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: sans-serif;
            font-size: 24px;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        #controls-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.6);
            font-family: sans-serif;
            font-size: 12px;
            pointer-events: none;
        }
    </style>
</head>

<body>
    <div id="loading">Generating Spheres...</div>
    <!-- Added a recording indicator -->
    <div id="recording-status"
        style="position: absolute; top: 20px; right: 20px; color: red; font-family: sans-serif; font-weight: bold; display: none; align-items: center; gap: 10px;">
        <div style="width: 12px; height: 12px; background-color: red; border-radius: 50%;"></div>
        RECORDING...
    </div>
    <div id="controls-info">Mouse: Orbit | Scroll: Zoom | Right-Click: Pan</div>

    <!-- Three.js and dependencies -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <!-- Simplex Noise for organic terrain generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <!-- lil-gui for controls -->
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/dist/lil-gui.umd.min.js"></script>

    <!-- Post-Processing Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <script>
        // Configuration
        const CONFIG = {
            sphereCount: 100, // Grid size (100x100 = 10,000 spheres)
            sphereSize: 0.4,
            spacing: 0.7,
            sphereDetail: 32, // Increased from 16 to 32 for smoother spheres
            jitter: 0.15, // Random position offset
            animSpeed: 0.002,
            isPaused: false,
            autoRotate: true,
            // Shape Settings
            gridShape: 'Grid', // 'Grid', 'Sphere', 'Cube'
            particleShape: 'Sphere', // 'Sphere', 'Cube', 'Plus'
            shapeSize: 30.0, // Radius for sphere, Side for cube
            // Wave Settings
            waveAmplitude: 2.0,
            waveFrequencyX: 0.1,
            waveFrequencyZ: 0.1,
            waveSpeed: 0.01,
            // Noise Settings
            noiseStrength: 2.0,
            noiseScale: 0.05,
            noiseSpeed: 0.005,
            // Interaction Settings
            interactionRadius: 8.0,
            interactionStrength: 5.0,
            interactionType: 'Repel', // 'Repel', 'Attract'
            // Audio Settings
            audioEnabled: false,
            audioSensitivity: 1.0,
            audioSource: 'Mic', // 'Mic', 'File'
            // Environment
            fogDensity: 0.02,
            showFloor: false,
            colors: {
                base: 0xcbbae8,    // Low points
                highlight: 0x8332a9, // High points
                bg: new THREE.Color(0x050505)
            },
            // Export settings
            exportDuration: 10, // seconds
            exportFormat: 'webm', // 'webm' or 'mp4'
            // Post-Processing
            bloomStrength: 0,
            bloomRadius: 0.4,
            bloomThreshold: 0.1,
            enableBloom: true,
            // Cluster Randomization
            clusterScale: 0.02, // Controls size of clusters (lower = larger clusters)
            clusterStrength: 0.5, // 15% variation
            // Material
            materialType: 'Metal'
        };

        const MATERIALS = {
            'Metal': { roughness: 0.2, metalness: 0.6 },
            'Plastic': { roughness: 0.5, metalness: 0.0 },
            'Clay': { roughness: 0.9, metalness: 0.0 },
            'Ceramic': { roughness: 0.1, metalness: 0.1 }
        };

        // Scene Management Variables
        const SCENE_MANAGER = {
            sceneName: "My Scene 1",
            selectedScene: "",
            savedScenes: {}, // Will be loaded from localStorage

            // Actions
            saveScene: function () {
                if (!this.sceneName) return alert("Please enter a scene name");

                const sceneData = {
                    config: JSON.parse(JSON.stringify(CONFIG)), // Deep copy config
                    camera: {
                        position: camera.position.clone(),
                        target: controls.target.clone()
                    },
                    lights: {
                        dir: {
                            position: dirLight.position.clone(),
                            intensity: dirLight.intensity
                        },
                        point: {
                            position: redLight.position.clone(),
                            intensity: redLight.intensity,
                            distance: redLight.distance
                        },
                        ambient: {
                            intensity: ambientLight.intensity,
                            color: ambientLight.color.getHex(),
                            groundColor: ambientLight.groundColor.getHex()
                        },
                        rim: {
                            position: rimLight.position.clone(),
                            intensity: rimLight.intensity,
                            color: rimLight.color.getHex()
                        }
                    }
                };

                // Fix Color objects turning into weird JSON
                // (CONFIG.colors is already hex/int friendly from previous edits, but let's be safe)

                this.savedScenes[this.sceneName] = sceneData;
                localStorage.setItem('sphere_field_scenes', JSON.stringify(this.savedScenes));

                // Update dropdown
                updateSceneDropdown();
                this.selectedScene = this.sceneName;
                alert(`Scene "${this.sceneName}" saved!`);
            },

            loadSelected: function () {
                const name = this.selectedScene;
                const data = this.savedScenes[name];
                if (!data) return alert("No scene selected");

                // 1. Restore Config
                Object.assign(CONFIG, data.config);

                // Migration: Old Crater Colors -> New Wave Colors
                if (CONFIG.colors.red !== undefined) {
                    CONFIG.colors.highlight = CONFIG.colors.red;
                    delete CONFIG.colors.red;
                }
                if (CONFIG.colors.purple !== undefined) {
                    CONFIG.colors.base = CONFIG.colors.purple;
                    delete CONFIG.colors.purple;
                }
                // Migration: Ensure Wave Defaults
                if (CONFIG.waveAmplitude === undefined) {
                    CONFIG.waveAmplitude = 2.0;
                    CONFIG.waveFrequencyX = 0.2;
                    CONFIG.waveFrequencyZ = 0.2;
                    CONFIG.waveSpeed = 1.0;
                }
                // Migration: Ensure Noise Defaults
                if (CONFIG.noiseStrength === undefined) {
                    CONFIG.noiseStrength = 0.0;
                    CONFIG.noiseScale = 0.1;
                    CONFIG.noiseSpeed = 0.5;
                }
                // Migration: Ensure Shape Defaults
                if (CONFIG.gridShape === undefined) {
                    CONFIG.gridShape = 'Grid';
                    CONFIG.shapeSize = 30.0;
                }
                if (CONFIG.particleShape === undefined) CONFIG.particleShape = 'Sphere';

                // Migration: Ensure Interaction Defaults
                if (CONFIG.interactionRadius === undefined) CONFIG.interactionRadius = 8.0;
                if (CONFIG.interactionStrength === undefined) CONFIG.interactionStrength = 5.0;
                if (CONFIG.interactionType === undefined) CONFIG.interactionType = 'Repel';

                // Migration: Ensure Audio Defaults
                if (CONFIG.audioEnabled === undefined) CONFIG.audioEnabled = false;
                if (CONFIG.audioSensitivity === undefined) CONFIG.audioSensitivity = 1.0;
                if (CONFIG.audioSource === undefined) CONFIG.audioSource = 'Mic';

                // Migration: Ensure Control Defaults
                if (CONFIG.isPaused === undefined) CONFIG.isPaused = false;
                if (CONFIG.autoRotate === undefined) CONFIG.autoRotate = true;

                // Migration: Ensure Environment Defaults
                if (CONFIG.fogDensity === undefined) CONFIG.fogDensity = 0.02;
                if (CONFIG.showFloor === undefined) CONFIG.showFloor = false;

                // Ensure colors are valid numbers/objects

                // 2. Restore Camera
                if (data.camera) {
                    camera.position.copy(data.camera.position);
                    controls.target.copy(data.camera.target);
                    controls.update();
                }

                // 3. Restore Lights
                if (data.lights) {
                    dirLight.position.copy(data.lights.dir.position);
                    dirLight.intensity = data.lights.dir.intensity;

                    redLight.position.copy(data.lights.point.position);
                    redLight.intensity = data.lights.point.intensity;
                    redLight.distance = data.lights.point.distance;

                    if (data.lights.ambient) {
                        ambientLight.intensity = data.lights.ambient.intensity;
                        ambientLight.color.setHex(data.lights.ambient.color);
                        ambientLight.groundColor.setHex(data.lights.ambient.groundColor);
                    }

                    if (data.lights.rim) {
                        rimLight.position.copy(data.lights.rim.position);
                        rimLight.intensity = data.lights.rim.intensity;
                        rimLight.color.setHex(data.lights.rim.color);
                    }
                }

                // 4. Update GUI to reflect new values
                // We recursively update all controllers in the GUI
                gui.controllersRecursive().forEach(c => c.updateDisplay());

                // 5. Re-init logic
                document.getElementById('loading').style.opacity = 1;
                setTimeout(() => {
                    initSpheres();
                    // Force background update
                    scene.background = new THREE.Color(CONFIG.colors.bg);
                    scene.fog.color = new THREE.Color(CONFIG.colors.bg);
                    scene.fog.density = CONFIG.fogDensity;

                    floor.visible = CONFIG.showFloor;
                }, 50);
            },

            deleteScene: function () {
                if (!this.selectedScene) return;
                if (confirm(`Delete scene "${this.selectedScene}"?`)) {
                    delete this.savedScenes[this.selectedScene];
                    localStorage.setItem('sphere_field_scenes', JSON.stringify(this.savedScenes));
                    updateSceneDropdown();
                    this.selectedScene = "";
                }
            }
        };

        // Setup Scene
        const scene = new THREE.Scene();
        scene.background = CONFIG.colors.bg;
        scene.fog = new THREE.FogExp2(CONFIG.colors.bg, CONFIG.fogDensity);

        // Floor Plane
        const floorGeo = new THREE.PlaneGeometry(400, 400);
        const floorMat = new THREE.MeshStandardMaterial({
            color: 0x111111,
            roughness: 0.1,
            metalness: 0.5
        });
        const floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -10; // Below the lowest wave point
        floor.receiveShadow = true;
        floor.visible = CONFIG.showFloor;
        scene.add(floor);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(20, 15, 20);

        const renderer = new THREE.WebGLRenderer({
            antialias: true,
            powerPreference: 'high-performance'
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        // Added Pixel Ratio for sharp rendering on high-DPI screens (Retina displays)
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        // Controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // Post-Processing Setup
        const renderScene = new THREE.RenderPass(scene, camera);

        const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = CONFIG.bloomThreshold;
        bloomPass.strength = CONFIG.bloomStrength;
        bloomPass.radius = CONFIG.bloomRadius;

        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // Lighting
        const ambientLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
        scene.add(ambientLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(50, 50, 20);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 150;
        dirLight.shadow.camera.near = 0.5;
        dirLight.shadow.camera.far = 150;
        dirLight.shadow.camera.left = -100;
        dirLight.shadow.camera.right = 100;
        dirLight.shadow.camera.top = 100;
        dirLight.shadow.camera.bottom = -100;
        dirLight.shadow.bias = -0.0005;
        scene.add(dirLight);

        // Add a specific light for the red crater to make it pop
        // Add a specific light for the red crater to make it pop
        const redLight = new THREE.PointLight(0xff5555, 2.0, 30); // Increased intensity and range for bloom
        redLight.position.set(0, 2, 0);
        scene.add(redLight);

        // Rim Light (Backlight) for cinematic separation
        const rimLight = new THREE.SpotLight(0x4455ff, 2.0);
        rimLight.position.set(-20, 10, -20);
        rimLight.lookAt(0, 0, 0);
        scene.add(rimLight);

        // Variables that need to be accessed globally for regeneration
        let mesh;
        let positions = [];
        let interactionMesh; // Invisible mesh for raycasting
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let interactionTarget = new THREE.Vector3(10000, 10000, 10000); // Far away initially

        // Mouse Move Handler
        window.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        });
        const simplex = new SimplexNoise();
        const dummy = new THREE.Object3D();
        const _color = new THREE.Color();
        // Helper color objects for the GUI
        const _baseColor = new THREE.Color();
        const _highlightColor = new THREE.Color();

        // Helper class for GUI colors
        class ColorGUIHelper {
            constructor(object, prop) {
                this.object = object;
                this.prop = prop;
            }
            get value() {
                return `#${this.object[this.prop].getHexString()}`;
            }
            set value(hexString) {
                this.object[this.prop].set(hexString);
            }
        }

        // Recording Logic
        function exportVideo() {
            const statusEl = document.getElementById('recording-status');
            const canvas = renderer.domElement;

            // Check support
            if (!window.MediaRecorder) {
                alert("Your browser does not support MediaRecorder API");
                return;
            }

            statusEl.style.display = 'flex';

            // Capture the stream at 30fps
            const stream = canvas.captureStream(30);

            // Determine Mime Type based on selection and support
            let mimeType = '';
            if (CONFIG.exportFormat === 'mp4') {
                if (MediaRecorder.isTypeSupported('video/mp4;codecs=h264')) {
                    mimeType = 'video/mp4;codecs=h264';
                } else if (MediaRecorder.isTypeSupported('video/mp4')) {
                    mimeType = 'video/mp4';
                } else {
                    alert("MP4 export is not supported by your browser. Falling back to WebM.");
                    CONFIG.exportFormat = 'webm'; // Fallback
                }
            }

            // If still empty (webm selected or fallback)
            if (!mimeType) {
                const webmTypes = [
                    'video/webm;codecs=vp9',
                    'video/webm;codecs=vp8',
                    'video/webm'
                ];
                mimeType = webmTypes.find(type => MediaRecorder.isTypeSupported(type)) || '';
            }

            if (!mimeType) {
                alert("No supported video mime type found.");
                statusEl.style.display = 'none';
                return;
            }

            const extension = CONFIG.exportFormat === 'mp4' ? 'mp4' : 'webm';
            console.log(`Exporting ${CONFIG.exportFormat.toUpperCase()} with mimeType: ${mimeType}`);

            let recorder;
            try {
                recorder = new MediaRecorder(stream, {
                    mimeType: mimeType,
                    videoBitsPerSecond: 8000000 // 8 Mbps
                });
            } catch (e) {
                console.error("MediaRecorder creation failed", e);
                alert("Failed to create MediaRecorder: " + e.message);
                statusEl.style.display = 'none';
                return;
            }

            const chunks = [];

            recorder.ondataavailable = (e) => {
                if (e.data.size > 0) chunks.push(e.data);
            };

            recorder.onstop = () => {
                statusEl.style.display = 'none';

                if (chunks.length === 0) {
                    alert("Recording failed: No data captured.");
                    return;
                }

                const blob = new Blob(chunks, { type: mimeType });
                console.log(`Exporting video: ${blob.size} bytes, type: ${mimeType}`);

                // Use URL.createObjectURL for better performance and reliability
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;

                // Sanitize filename
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                a.download = `sphere-field-demo-${timestamp}.${extension}`;

                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                // Cleanup
                setTimeout(() => URL.revokeObjectURL(url), 1000);
            };

            recorder.start();

            // Stop after exportDuration
            setTimeout(() => {
                if (recorder.state === 'recording') {
                    recorder.stop();
                }
            }, CONFIG.exportDuration * 1000);
        }

        function initSpheres() {
            // Cleanup existing mesh if it exists
            if (mesh) {
                scene.remove(mesh);
                mesh.geometry.dispose();
                mesh.material.dispose();
                mesh = null;
                positions = [];
            }

            // Cleanup interaction mesh
            if (interactionMesh) {
                scene.remove(interactionMesh);
                interactionMesh.geometry.dispose();
                interactionMesh.material.dispose();
                interactionMesh = null;
            }

            // Create Interaction Mesh (Invisible)
            let interactionGeo;
            if (CONFIG.gridShape === 'Grid') {
                // Plane
                const size = CONFIG.sphereCount * CONFIG.spacing;
                interactionGeo = new THREE.PlaneGeometry(size, size);
                interactionGeo.rotateX(-Math.PI / 2); // Horizontal
            } else if (CONFIG.gridShape === 'Sphere') {
                interactionGeo = new THREE.SphereGeometry(CONFIG.shapeSize, 32, 32);
            } else if (CONFIG.gridShape === 'Cube') {
                const s = CONFIG.shapeSize;
                interactionGeo = new THREE.BoxGeometry(s, s, s);
            }

            if (interactionGeo) {
                const interactionMat = new THREE.MeshBasicMaterial({ visible: false }); // Invisible
                interactionMesh = new THREE.Mesh(interactionGeo, interactionMat);
                scene.add(interactionMesh);
            }

            // Use sphereDetail config here
            let geometry;
            const s = CONFIG.sphereSize;

            if (CONFIG.particleShape === 'Cube') {
                geometry = new THREE.BoxGeometry(s, s, s);
            } else if (CONFIG.particleShape === 'Plus') {
                const shape = new THREE.Shape();
                const t = s * 0.3; // thickness
                const h = s; // half size roughly

                shape.moveTo(t, h);
                shape.lineTo(h, h);
                shape.lineTo(h, -h);
                shape.lineTo(t, -h);
                shape.lineTo(t, -s * 2); // Long tail? No, let's make it symmetric
                // Actually, let's draw a proper cross
                // Center 0,0. Size s.
                // Top arm
                shape.moveTo(-t, s);
                shape.lineTo(t, s);
                shape.lineTo(t, t);
                // Right arm
                shape.lineTo(s, t);
                shape.lineTo(s, -t);
                shape.lineTo(t, -t);
                // Bottom arm
                shape.lineTo(t, -s);
                shape.lineTo(-t, -s);
                shape.lineTo(-t, -t);
                // Left arm
                shape.lineTo(-s, -t);
                shape.lineTo(-s, t);
                shape.lineTo(-t, t);

                geometry = new THREE.ShapeGeometry(shape);
            } else {
                // Default Sphere
                geometry = new THREE.SphereGeometry(s, CONFIG.sphereDetail, CONFIG.sphereDetail);
            }

            const matProps = MATERIALS[CONFIG.materialType] || MATERIALS['Metal'];
            const material = new THREE.MeshStandardMaterial({
                roughness: matProps.roughness,
                metalness: matProps.metalness,
                side: THREE.DoubleSide // Ensure 2D shapes are visible from both sides
            });

            const count = CONFIG.sphereCount * CONFIG.sphereCount;
            mesh = new THREE.InstancedMesh(geometry, material, count);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            let index = 0;

            if (CONFIG.gridShape === 'Grid') {
                const offset = (CONFIG.sphereCount * CONFIG.spacing) / 2;
                for (let x = 0; x < CONFIG.sphereCount; x++) {
                    for (let z = 0; z < CONFIG.sphereCount; z++) {
                        const posX = (x * CONFIG.spacing) - offset;
                        const posZ = (z * CONFIG.spacing) - offset;

                        const jitter = CONFIG.jitter;
                        const finalX = posX + (Math.random() * jitter - jitter / 2);
                        const finalZ = posZ + (Math.random() * jitter - jitter / 2);

                        positions.push({
                            baseX: finalX,
                            baseY: 0,
                            baseZ: finalZ,
                            normX: 0,
                            normY: 1,
                            normZ: 0,
                            idx: index,
                            colorOffset: Math.random()
                        });
                        index++;
                    }
                }
            } else if (CONFIG.gridShape === 'Sphere') {
                // Fibonacci Sphere
                for (let i = 0; i < count; i++) {
                    const phi = Math.acos(1 - 2 * (i + 0.5) / count);
                    const theta = Math.PI * (1 + Math.sqrt(5)) * i;

                    const x = Math.cos(theta) * Math.sin(phi);
                    const y = Math.cos(phi);
                    const z = Math.sin(theta) * Math.sin(phi);

                    const r = CONFIG.shapeSize;

                    // Apply Cartesian Jitter to match Grid behavior
                    const jX = (Math.random() * CONFIG.jitter - CONFIG.jitter / 2);
                    const jY = (Math.random() * CONFIG.jitter - CONFIG.jitter / 2);
                    const jZ = (Math.random() * CONFIG.jitter - CONFIG.jitter / 2);

                    positions.push({
                        baseX: (x * r) + jX,
                        baseY: (y * r) + jY,
                        baseZ: (z * r) + jZ,
                        normX: x,
                        normY: y,
                        normZ: z,
                        idx: index,
                        colorOffset: Math.random()
                    });
                    index++;
                }
            } else if (CONFIG.gridShape === 'Cube') {
                // Distribute points on 6 faces
                const side = CONFIG.shapeSize;
                const half = side / 2;
                const pointsPerFace = Math.floor(count / 6);
                const gridDim = Math.floor(Math.sqrt(pointsPerFace));

                // Use (gridDim - 1) to ensure points reach the edges (inclusive)
                // If gridDim <= 1, fallback to center
                const step = gridDim > 1 ? side / (gridDim - 1) : 0;
                const offset = side / 2;

                const faces = [
                    { u: 'x', v: 'y', w: 'z', wVal: half, n: { x: 0, y: 0, z: 1 } },  // Front
                    { u: 'x', v: 'y', w: 'z', wVal: -half, n: { x: 0, y: 0, z: -1 } }, // Back
                    { u: 'z', v: 'y', w: 'x', wVal: half, n: { x: 1, y: 0, z: 0 } },  // Right
                    { u: 'z', v: 'y', w: 'x', wVal: -half, n: { x: -1, y: 0, z: 0 } }, // Left
                    { u: 'x', v: 'z', w: 'y', wVal: half, n: { x: 0, y: 1, z: 0 } },  // Top
                    { u: 'x', v: 'z', w: 'y', wVal: -half, n: { x: 0, y: -1, z: 0 } }  // Bottom
                ];

                for (const face of faces) {
                    for (let i = 0; i < gridDim; i++) {
                        for (let j = 0; j < gridDim; j++) {
                            // Calculate position. If gridDim=1, pos is 0 (center)
                            const uPos = gridDim > 1 ? (i * step) - offset : 0;
                            const vPos = gridDim > 1 ? (j * step) - offset : 0;

                            // Apply Jitter
                            const jU = uPos + (Math.random() * CONFIG.jitter - CONFIG.jitter / 2);
                            const jV = vPos + (Math.random() * CONFIG.jitter - CONFIG.jitter / 2);
                            // Also jitter the depth slightly? No, keep faces flat unless noise is added.
                            // Actually, for consistency, maybe jitter depth too? 
                            // Let's jitter depth too so it's a "fuzzy cube" if jitter is high
                            const jW = face.wVal + (Math.random() * CONFIG.jitter - CONFIG.jitter / 2);

                            const pos = { x: 0, y: 0, z: 0 };
                            pos[face.u] = jU;
                            pos[face.v] = jV;
                            pos[face.w] = jW;

                            positions.push({
                                baseX: pos.x,
                                baseY: pos.y,
                                baseZ: pos.z,
                                normX: face.n.x,
                                normY: face.n.y,
                                normZ: face.n.z,
                                idx: index,
                                colorOffset: Math.random()
                            });
                            index++;
                        }
                    }
                }
            }

            updateSpheres(0);
            document.getElementById('loading').style.opacity = 0;
        }

        function updateSpheres(time, audioBass = 0, audioMids = 0, audioHighs = 0) {
            if (!mesh) return;

            // Update helper colors from config numbers
            _baseColor.setHex(CONFIG.colors.base);
            _highlightColor.setHex(CONFIG.colors.highlight);

            // Audio Modulation
            const s = CONFIG.audioSensitivity;
            const modAmp = CONFIG.waveAmplitude + (audioBass * 5.0 * s); // Bass drives amplitude
            const modNoise = CONFIG.noiseStrength + (audioMids * 5.0 * s); // Mids drive noise
            // Highs will drive color brightness/highlight mix

            for (let i = 0; i < positions.length; i++) {
                const { baseX, baseY, baseZ, normX, normY, normZ, idx, colorOffset } = positions[i];

                // 1. Generate Displacement using Wave Logic
                // Use base positions for wave inputs

                const t = time * CONFIG.waveSpeed;
                const waveX = Math.sin(baseX * CONFIG.waveFrequencyX + t);
                const waveZ = Math.cos(baseZ * CONFIG.waveFrequencyZ + t);
                // Add Y contribution for 3D shapes
                const waveY = Math.sin(baseY * CONFIG.waveFrequencyX + t);

                let displacement = (waveX + waveZ + waveY) * modAmp;

                // Apply Noise
                if (modNoise > 0) {
                    const n = simplex.noise3D(baseX * CONFIG.noiseScale, baseZ * CONFIG.noiseScale, time * CONFIG.noiseSpeed);
                    displacement += n * modNoise;
                }

                // Apply Interaction Force
                const dist = interactionTarget.distanceToSquared(new THREE.Vector3(baseX, baseY, baseZ)); // Approx distance to base
                // Actually, distanceToSquared is faster. Radius squared.
                const rSq = CONFIG.interactionRadius * CONFIG.interactionRadius;

                if (dist < rSq) {
                    // Calculate falloff (1 at center, 0 at edge)
                    const falloff = Math.pow(1.0 - (dist / rSq), 2);
                    const force = falloff * CONFIG.interactionStrength;

                    if (CONFIG.interactionType === 'Repel') {
                        displacement += force;
                    } else {
                        displacement -= force;
                    }
                }

                // 2. Position Object
                // finalPos = basePos + (normal * displacement)
                const x = baseX + (normX * displacement);
                const y = baseY + (normY * displacement);
                const z = baseZ + (normZ * displacement);

                dummy.position.set(x, y, z);

                // Orient sphere to normal (optional, but good for non-spherical shapes if we used non-spheres)
                // dummy.lookAt(x + normX, y + normY, z + normZ);

                // Scale spheres slightly based on displacement
                // Scale spheres slightly based on displacement
                const totalAmp = (modAmp * 3) + modNoise + 0.001;
                const normDisp = (displacement / totalAmp) + 0.5; // 0 to 1 roughly

                let scale = 1.0 + (normDisp * 0.5);

                // Audio Highs affect scale jitter
                scale += (audioHighs * s * Math.random());

                // Apply Cluster Randomization
                const clusterNoise = simplex.noise2D(x * CONFIG.clusterScale + 100, z * CONFIG.clusterScale + 100);
                scale *= (1.0 + (clusterNoise * CONFIG.clusterStrength));

                dummy.scale.set(scale, scale, scale);

                dummy.updateMatrix();
                mesh.setMatrixAt(idx, dummy.matrix);

                // 3. Color Logic
                // Map displacement to color
                // Audio Highs push color towards highlight
                let mix = Math.max(0, Math.min(1, normDisp));
                mix += (audioHighs * s);

                _color.copy(_baseColor).lerp(_highlightColor, Math.max(0, Math.min(1, mix)));

                // Add a little random variation
                _color.offsetHSL(0, 0, (colorOffset - 0.5) * 0.1);

                mesh.setColorAt(idx, _color);
            }
            mesh.instanceMatrix.needsUpdate = true;
            mesh.instanceColor.needsUpdate = true;
        }

        // Initialize
        initSpheres();

        // GUI Setup
        const gui = new lil.GUI();

        // Load scenes from storage
        try {
            const stored = localStorage.getItem('sphere_field_scenes');
            if (stored) {
                SCENE_MANAGER.savedScenes = JSON.parse(stored);
            }
        } catch (e) { console.error("Error loading scenes", e); }

        // SCENE MANAGEMENT FOLDER
        const savesFolder = gui.addFolder('Scene Manager');
        savesFolder.add(SCENE_MANAGER, 'sceneName').name('Scene Name');
        savesFolder.add(SCENE_MANAGER, 'saveScene').name('Save Current Scene');

        let sceneController;
        function updateSceneDropdown() {
            // Remove old controller if exists
            if (sceneController) sceneController.destroy();

            const options = Object.keys(SCENE_MANAGER.savedScenes);
            if (options.length > 0) {
                sceneController = savesFolder.add(SCENE_MANAGER, 'selectedScene', options).name('Saved Scenes');
            } else {
                // Placeholder if empty
                SCENE_MANAGER.selectedScene = "";
                sceneController = savesFolder.add(SCENE_MANAGER, 'selectedScene', ["No scenes"]).name('Saved Scenes').disable();
            }
        }
        updateSceneDropdown();

        savesFolder.add(SCENE_MANAGER, 'loadSelected').name('Load Selected');
        savesFolder.add(SCENE_MANAGER, 'deleteScene').name('Delete Selected');

        const simFolder = gui.addFolder('Simulation');
        simFolder.add(CONFIG, 'isPaused').name('Pause Animation');
        simFolder.add(CONFIG, 'autoRotate').name('Auto Rotate');
        simFolder.add(CONFIG, 'sphereCount', 10, 200, 1)
            .name('Grid Size')
            .onFinishChange(() => {
                document.getElementById('loading').style.opacity = 1;
                setTimeout(initSpheres, 50);
            });

        simFolder.add(CONFIG, 'sphereSize', 0.1, 1.5)
            .name('Particle Size')
            .onFinishChange(() => {
                document.getElementById('loading').style.opacity = 1;
                setTimeout(initSpheres, 50);
            });

        simFolder.add(CONFIG, 'particleShape', ['Sphere', 'Cube', 'Plus'])
            .name('Particle Shape')
            .onFinishChange(() => {
                document.getElementById('loading').style.opacity = 1;
                setTimeout(initSpheres, 50);
            });

        // NEW: Spacing control to adjust the gap between spheres
        simFolder.add(CONFIG, 'spacing', 0.1, 2.0)
            .name('Spacing')
            .onFinishChange(() => {
                document.getElementById('loading').style.opacity = 1;
                setTimeout(initSpheres, 50);
            });

        // Added Sphere Detail Control
        simFolder.add(CONFIG, 'sphereDetail', 8, 64, 1)
            .name('Sphere Detail')
            .onFinishChange(() => {
                document.getElementById('loading').style.opacity = 1;
                setTimeout(initSpheres, 50);
            });

        simFolder.add(CONFIG, 'jitter', 0, 1.0)
            .name('Grid Jitter')
            .onFinishChange(() => {
                document.getElementById('loading').style.opacity = 1;
                setTimeout(initSpheres, 50);
            });

        simFolder.add(CONFIG, 'gridShape', ['Grid', 'Sphere', 'Cube'])
            .name('Shape')
            .onFinishChange(() => {
                document.getElementById('loading').style.opacity = 1;
                setTimeout(initSpheres, 50);
            });

        simFolder.add(CONFIG, 'shapeSize', 5, 100)
            .name('Shape Size')
            .onFinishChange(() => {
                document.getElementById('loading').style.opacity = 1;
                setTimeout(initSpheres, 50);
            });

        simFolder.add({
            resetToPerfect: () => {
                CONFIG.jitter = 0;
                CONFIG.waveAmplitude = 0;
                CONFIG.noiseStrength = 0;
                // Keep interaction settings as is, or reset? Let's keep them.

                // Update GUI controllers
                gui.controllersRecursive().forEach(c => c.updateDisplay());
                initSpheres();
            }
        }, 'resetToPerfect').name('Reset to Perfect');

        const fixOverlap = () => {
            // Calculate minimum safe spacing
            // Diameter = sphereSize * 2
            // Max Scale = 1.0 + (clusterStrength) + (noise * 0.2) -> roughly 1.0 + 0.15 + 0.2 = 1.35
            // Let's be safe and assume max scale is around 1.4
            const maxScale = 1.0 + CONFIG.clusterStrength + 0.2;
            const maxDiameter = (CONFIG.sphereSize * 2) * maxScale;

            // Jitter adds +/- jitter/2 to position. Max spread between two points is jitter.
            // So we need spacing > maxDiameter + jitter

            const safeSpacing = maxDiameter + CONFIG.jitter + 0.05; // 0.05 buffer

            CONFIG.spacing = safeSpacing;

            // Update GUI
            // We need to find the controller for spacing. 
            // Since we don't have a direct reference easily without iterating, 
            // we can just update the display of all controllers in this folder.
            simFolder.controllers.forEach(c => c.updateDisplay());

            initSpheres();
            alert(`Spacing adjusted to ${safeSpacing.toFixed(3)} to prevent overlap.`);
        };

        simFolder.add({ fixOverlap }, 'fixOverlap').name('Auto-Fix Overlap');

        simFolder.add(CONFIG, 'materialType', Object.keys(MATERIALS))
            .name('Material')
            .onFinishChange(() => {
                document.getElementById('loading').style.opacity = 1;
                setTimeout(initSpheres, 50);
            });

        simFolder.add(CONFIG, 'animSpeed', 0, 0.01).name('Anim Speed');

        const waveFolder = gui.addFolder('Wave Controls');
        waveFolder.add(CONFIG, 'waveAmplitude', 0, 10).name('Amplitude');
        waveFolder.add(CONFIG, 'waveFrequencyX', 0, 1.0).name('Frequency X');
        waveFolder.add(CONFIG, 'waveFrequencyZ', 0, 1.0).name('Frequency Z');
        waveFolder.add(CONFIG, 'waveSpeed', 0, 5.0).name('Speed');
        waveFolder.addColor(CONFIG.colors, 'base').name('Base Color');
        waveFolder.addColor(CONFIG.colors, 'highlight').name('Highlight Color');

        const noiseFolder = gui.addFolder('Noise Controls');
        noiseFolder.add(CONFIG, 'noiseStrength', 0, 10).name('Strength');
        noiseFolder.add(CONFIG, 'noiseScale', 0.001, 0.2).name('Scale');
        noiseFolder.add(CONFIG, 'noiseSpeed', 0, 0.05).name('Speed');

        const interactFolder = gui.addFolder('Interaction');
        interactFolder.add(CONFIG, 'interactionRadius', 1, 30).name('Radius');
        interactFolder.add(CONFIG, 'interactionStrength', 0, 20).name('Strength');
        interactFolder.add(CONFIG, 'interactionType', ['Repel', 'Attract']).name('Type');

        const audioFolder = gui.addFolder('Audio Reactivity');
        audioFolder.add({ startMic: () => setupAudio('Mic') }, 'startMic').name('Start Microphone');
        audioFolder.add({ playFile: () => setupAudio('File') }, 'playFile').name('Upload Audio File');
        audioFolder.add({ stopAudio }, 'stopAudio').name('Stop Audio');
        audioFolder.add(CONFIG, 'audioSensitivity', 0, 5.0).name('Sensitivity');

        const envFolder = gui.addFolder('Environment');
        envFolder.add(CONFIG, 'fogDensity', 0, 0.1).name('Fog Density')
            .onChange(v => scene.fog.density = v);
        envFolder.add(CONFIG, 'showFloor').name('Show Floor')
            .onChange(v => floor.visible = v);

        const sunFolder = gui.addFolder('Sun Light (Directional)');
        sunFolder.add(dirLight.position, 'x', -100, 100).name('Pos X');
        sunFolder.add(dirLight.position, 'y', 0, 100).name('Pos Y');
        sunFolder.add(dirLight.position, 'z', -100, 100).name('Pos Z');
        sunFolder.add(dirLight, 'intensity', 0, 3).name('Intensity');

        const ambientFolder = gui.addFolder('Ambient Light');
        ambientFolder.add(ambientLight, 'intensity', 0, 2).name('Intensity');
        ambientFolder.addColor(new ColorGUIHelper(ambientLight, 'color'), 'value').name('Sky Color');
        ambientFolder.addColor(new ColorGUIHelper(ambientLight, 'groundColor'), 'value').name('Ground Color');

        const rimFolder = gui.addFolder('Rim Light (Spot)');
        rimFolder.add(rimLight.position, 'x', -50, 50).name('Pos X');
        rimFolder.add(rimLight.position, 'y', 0, 50).name('Pos Y');
        rimFolder.add(rimLight.position, 'z', -50, 50).name('Pos Z');
        rimFolder.add(rimLight, 'intensity', 0, 5).name('Intensity');
        rimFolder.addColor(new ColorGUIHelper(rimLight, 'color'), 'value').name('Color');

        const redFolder = gui.addFolder('Point Light');
        redFolder.add(redLight.position, 'x', -50, 50).name('Pos X');
        redFolder.add(redLight.position, 'y', 0, 50).name('Pos Y');
        redFolder.add(redLight.position, 'z', -50, 50).name('Pos Z');
        redFolder.add(redLight, 'intensity', 0, 5).name('Intensity');
        redFolder.add(redLight, 'distance', 0, 100).name('Distance (Range)');

        const exportFolder = gui.addFolder('Export');
        exportFolder.add(CONFIG, 'exportDuration', 1, 60, 1).name('Duration (sec)');
        exportFolder.add(CONFIG, 'exportFormat', ['webm', 'mp4']).name('Format');
        exportFolder.add({ exportVideo }, 'exportVideo').name('Record Video');

        const bloomFolder = gui.addFolder('Post-Processing (Bloom)');
        bloomFolder.add(CONFIG, 'enableBloom').name('Enable Bloom');
        bloomFolder.add(CONFIG, 'bloomStrength', 0, 3).onChange(v => bloomPass.strength = v);
        bloomFolder.add(CONFIG, 'bloomRadius', 0, 1).onChange(v => bloomPass.radius = v);
        bloomFolder.add(CONFIG, 'bloomThreshold', 0, 1).onChange(v => bloomPass.threshold = v);

        const clusterFolder = gui.addFolder('Cluster Randomization');
        clusterFolder.add(CONFIG, 'clusterScale', 0.01, 0.5).name('Cluster Scale (Size)');
        clusterFolder.add(CONFIG, 'clusterStrength', 0, 0.5).name('Variation Strength');



        function updateInteraction() {
            if (!interactionMesh) return;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(interactionMesh);

            if (intersects.length > 0) {
                interactionTarget.copy(intersects[0].point);
            } else {
                interactionTarget.set(10000, 10000, 10000); // Reset if off mesh
            }
        }

        // --- AUDIO REACTIVITY SETUP ---
        let audioContext, analyser, dataArray, source;
        let audioEl; // For file playback

        async function setupAudio(type) {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }

            // Cleanup old source
            if (source) {
                source.disconnect();
                if (audioEl) {
                    audioEl.pause();
                    audioEl = null;
                }
            }

            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256; // 128 bins
            dataArray = new Uint8Array(analyser.frequencyBinCount);

            if (type === 'Mic') {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    source = audioContext.createMediaStreamSource(stream);
                    source.connect(analyser);
                    alert("Microphone connected! Speak or clap to see effects.");
                } catch (err) {
                    console.error("Mic Error:", err);
                    alert("Could not access microphone. Check permissions.");
                }
            } else if (type === 'File') {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'audio/*';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const url = URL.createObjectURL(file);
                        audioEl = new Audio(url);
                        audioEl.play();
                        audioEl.loop = true;
                        source = audioContext.createMediaElementSource(audioEl);
                        source.connect(analyser);
                        source.connect(audioContext.destination); // Play to speakers
                    }
                };
                input.click();
            }

            CONFIG.audioEnabled = true;
        }

        function stopAudio() {
            if (source) {
                source.disconnect();
                // If it's a media stream (Mic), stop the tracks to release the mic
                if (source.mediaStream) {
                    source.mediaStream.getTracks().forEach(track => track.stop());
                }
                source = null;
            }

            if (audioEl) {
                audioEl.pause();
                audioEl.src = "";
                audioEl = null;
            }

            CONFIG.audioEnabled = false;
            // Reset modulation values in next frame automatically by logic
        }

        // Animation Loop
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);

            updateInteraction();

            // Audio Analysis
            let bass = 0, mids = 0, highs = 0;
            if (CONFIG.audioEnabled && analyser) {
                analyser.getByteFrequencyData(dataArray);

                // Simple frequency bands (fftSize 256 -> 128 bins)
                // 0-10: Bass
                // 11-60: Mids
                // 61-127: Highs

                const getAvg = (start, end) => {
                    let sum = 0;
                    for (let i = start; i <= end; i++) sum += dataArray[i];
                    return sum / (end - start + 1);
                };

                bass = getAvg(0, 10) / 255; // 0.0 to 1.0
                mids = getAvg(11, 60) / 255;
                highs = getAvg(61, 127) / 255;

                // Modulate CONFIG values temporarily for this frame
                // We need to store base values if we want to return to them, 
                // but for now let's just ADD to the base config.

                // Actually, let's just pass these modifiers to updateSpheres
            }

            if (!CONFIG.isPaused) {
                time += CONFIG.animSpeed;
                updateSpheres(time, bass, mids, highs);
            } else {
                // Even if paused, we might want interaction to work?
                // Let's allow interaction updates even when paused for fun
                updateSpheres(time, bass, mids, highs);
            }

            controls.autoRotate = CONFIG.autoRotate;
            controls.update();

            // Bloom
            if (CONFIG.enableBloom) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }

        animate();

        // Resize Handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>

</html>
